Základy počítačové grafiky 2023/2024

Jméno a příjmení: Václav Vyrobík
Login: VYR0020

V několika větách popište kde máte ve zdrojovém kódu danou věc (třída, řádek), jak funguje a jaké má výhody/nevýhody. Splněno nechte, jen pokud je vše splněno a funkční, jinak nesplněno. 


1. Třída ShaderProgram
----------------------
  a) splněno
     Popis: Má třída se jmenuje Shader. Mé ID shaderu dědím z ShaderLoaderu kde jej i nastavuji a je protected tím pátem k němu nemá nikdo jiný přístup (jen a pouze Shader). Při vytváření shaderu vytvářím už konkrétní typ (Phong, Constant atd - tyto typy dědí ze třídy Shader), kdy při vytvoření nastavím proměnnou shaderType která je typu ShaderType kde jsou uloženy jednotlivé typy (enum class).

  b) splněno 
     Popis: Shader lze nastavim pomocí metody useProgram() a zrušit jeho nastavní pomocí unsetShader(). Zbytek věcí se nastavuje při vytváření v ShaderLoaderu. ShaderLoader také obsahuje metodu pro odstranění shaderu deleteShader().

  c) splněno
     Popis: Mám 3 přětížené metody - jednu pro posílání uniformních proměnných typu vec3 druhou pro mat4 a třetí float, kde posílám název a danou matici/vektor/float.

  d) splněno 
     Popis: Použil jsem Váš ShaderLoader, ze ktérého jsem podědil a využívám jeho konstruktor, kde si přiřazuje shaderID.
Výhodou je, že při vytváření do něj pošlu jen cestu k vertex a fragment shaderu a zbytek zařídí ShaderLoader, který zároveň i ukazuje errory v shaderech (snadnější debug). Zároveň objekty vykreslované stejným shaderem mají stejné shaderID (vyřazení zbytečného zatížení přiřazování nových shaderID). 


2. Třída DrawableModel
----------------------
  a) splněno
     Popis: Má třída se jmenuje DrawableObject a obsahuje shader, kterým je vykreslován, vektor transformací (Composite transformations), referenci na model a material. Obsahuje metody jako addTransformation, pomocí které můžu přidávat transformace, dále set light kde do shaderu posílám uniformní proměnné a nastavuji světlo a metodu setMaterial, kde si zjišťuji typ shaderu a podle toho pošlu do shaderu uniformní proměnné a nastavím material.


3. Transformace
----------------------
  a) splněno
     Popis: Objektu můžu přiřadit transformace jako rotace, translace a scale a je možno je kombinovat. Řešeno přes Composite (více popsáno v bodu d).

  b) nesplněno
     Popis: 

  c) splněno
     Popis: Rotace kolem tělesa, které není ve středu souřadné soustavy funguje (ukázka ve scéně 2 sluneční soustava) - nejprve objekt posunu na pozici druhého tělesa, zarotuji s ním a následně jej posunu na svou pozici.

  d) splněno
     Popis: Mám abstraktrní třídu Transformation, která obsahuje metodu traverse. Dále mám potomky třídy - jednotlivé transformace (TransformationTranslate/Rotate/Scale), které přepisují virtuální metodu traverse podle druhu transformace. Ze třídy Transformation dědí i třída Composite, která obsahuje vektor transformací (children) a metodu traverse, která provede tranformace na každém childu.


4. Třída Camera
----------------------
  a) splněno
     Popis: Kameru ovládám pomocí kláves WSAD, používám na to funkci processInput. Kameru a shadery měním jen pokud zmáčknu danou klávesu a něco se změní. Řešeno přes Observer.

  b) splněno
     Popis: Pohyb myší řeším funkcí mouseInput, kterou volám v callbacích a do kamery  posílám nové souřadnice myši pokud se změní (třída Callback si drží referenci na kameru). Řešeno přes observer.

  c) splněno
     Popis: Celý pohyb kamery je řešen přes Observer. Pokud se něco změní zavolá se metoda update, kde se updatují shadery. Do metody posílám referenci na objekt (Camera/Light) a typ změny co se stal (ChangeType::CameraMoved, WindowChanged atd.)


5. Třída Light
----------------------
  a) splněno
     Popis: Třída obsahuje pozici a barvu světla. Při změně pozice nebo barvy se zavolají metody update, které updatnou danou hodnotu a změní se také v shaderech. Řešeno přes observer kde zavolám notify a pošlu objekt světla a typ změny co se stal.

  b) splněno
     Popis: Pokud se něco změní ve světle změní se i v shaderu. Řešeno přes observer kde posílám referenci na dané světlo a typ změny co se ve světle stal podobně jako to řeším v kameře.

6. Třída Material
----------------------
  a) splněno 
     Popis: Obsahuje hodnoty ambient, diffuse, specular a objectColor které při vytvoření materiálu následně posílám do shaderu. Má přetížený konstruktor a můžu si vybrat jaký typ materiálu vytvořím.



Testovací scény  

1) Základní test Phongova osvětlovacího modelu.
----------------------
  splněno
  Popis: Čtyři sféry jsou rozmístěny naproti sobě a uprostřed je světlo. Při pohybu kamery můžeme vidět jak se mění zrcadlová složka.

2) Test na rotaci a jeji skládání. 
----------------------
  splněno
  Popis: Scéna obsahuje 3 planety (modré a tyrkysová), které obíhají kolem slunce (žlutá) - slunce není ve středu souřadné soustavy ale je posunuto o z souřadnici. Okolo jedné modré planety rotuje měsíc (šedá).

3) Test na ořezání světla, které nemůže dopadnou na plochu.
----------------------
  splněno
  Popis: Na testování jsem použil dva shadery (phong.frag a phong_wrong.frag - přiloženy), kde v jednom mám výsledek ošetřen podmínkou a v druhém nikoli. Výsledek je vidět na obrázcích.

4) Test na změnu velikosti obrazovky. 
----------------------
  splněno
  Popis: Řešeno v callbacích, kde při změně okna zavolám metodu windowChange a posílám zde nové rozměry okna. V kameře změním projekční matici a updatnu shadery - řešeno přes observer.

5) Testování na více objektů a použití více shaderu ve scéně (procházení lesa). 
----------------------
  splněno
  Popis: Pro testování renderuji 200 objektů, které jsou náhodně rozmístěny ve sceně, mají náhodnou velikost a jsou náhodně natočeny. Jsou také vykresleny náhodným shaderem a využívám náhodný model(suzi, tree, bushes, sphere). Všechny objekty "leží" na plain.